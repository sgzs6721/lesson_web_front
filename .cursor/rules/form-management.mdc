---
description: 
globs: 
alwaysApply: false
---
# 表单管理最佳实践

## 表单定义与管理

本项目中的表单管理遵循以下规范和最佳实践：

### 表单状态管理

- 使用Ant Design的Form组件及其hooks管理表单状态
- 表单实例通过Form.useForm()创建
- 复杂表单状态可以结合自定义hook进行管理

```tsx
// 基本表单状态管理
const [form] = Form.useForm();

// 复杂表单状态管理，结合自定义hook
const { form, initialValues, handleSubmit, loading } = useStudentForm(studentId);
```

### 表单验证规则

- 使用声明式规则定义验证逻辑
- 常用验证规则封装为工具函数
- 复杂验证规则使用自定义validator函数

```tsx
// 常见验证规则
const rules = {
  required: { required: true, message: '此项为必填项' },
  phone: { pattern: /^1[3-9]\d{9}$/, message: '请输入正确的手机号' },
  email: { type: 'email', message: '请输入正确的邮箱地址' },
  number: { type: 'number', message: '请输入数字' },
};

// 表单项使用验证规则
<Form.Item 
  name="phone" 
  label="联系电话" 
  rules={[rules.required, rules.phone]}
>
  <Input />
</Form.Item>

// 自定义验证器
const validatePrice = (_, value) => {
  if (value && value < 0) {
    return Promise.reject('价格不能为负数');
  }
  return Promise.resolve();
};

<Form.Item
  name="price"
  label="课程价格"
  rules={[
    { required: true, message: '请输入课程价格' },
    { validator: validatePrice }
  ]}
>
  <InputNumber />
</Form.Item>
```

### 嵌套表单

- 使用Form.List管理动态表单列表
- 使用嵌套字段名访问深层数据结构

```tsx
// 动态表单列表
<Form.List name="courses">
  {(fields, { add, remove }) => (
    <>
      {fields.map(field => (
        <div key={field.key}>
          <Form.Item
            {...field}
            name={[field.name, 'name']}
            label="课程名称"
            rules={[{ required: true, message: '请输入课程名称' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            {...field}
            name={[field.name, 'hours']}
            label="课时"
            rules={[{ required: true, message: '请输入课时' }]}
          >
            <InputNumber />
          </Form.Item>
          <Button onClick={() => remove(field.name)}>删除</Button>
        </div>
      ))}
      <Button onClick={() => add()}>添加课程</Button>
    </>
  )}
</Form.List>

// 嵌套字段访问
<Form.Item
  name={['address', 'province']}
  label="省份"
>
  <Select options={provinceOptions} />
</Form.Item>
<Form.Item
  name={['address', 'city']}
  label="城市"
>
  <Select options={cityOptions} />
</Form.Item>
```

## 常见表单模式

### 搜索表单

- 使用较为简洁的布局
- 实现表单重置功能
- 支持回车键提交

```tsx
const [form] = Form.useForm();

const handleSearch = (values) => {
  console.log('搜索参数:', values);
  fetchData(values);
};

const handleReset = () => {
  form.resetFields();
  fetchData({});
};

<Card>
  <Form
    form={form}
    layout="inline"
    onFinish={handleSearch}
  >
    <Form.Item name="name" label="学员姓名">
      <Input placeholder="请输入" allowClear />
    </Form.Item>
    <Form.Item name="status" label="状态">
      <Select
        placeholder="请选择"
        allowClear
        options={[
          { value: 'STUDYING', label: '在学' },
          { value: 'GRADUATED', label: '已结业' },
          { value: 'EXPIRED', label: '已过期' },
        ]}
      />
    </Form.Item>
    <Form.Item>
      <Space>
        <Button type="primary" htmlType="submit">
          搜索
        </Button>
        <Button onClick={handleReset}>重置</Button>
      </Space>
    </Form.Item>
  </Form>
</Card>
```

### 编辑表单

- 使用垂直布局
- 自动加载初始数据
- 实现表单提交和取消功能

```tsx
const EditForm = ({ id, onSuccess, onCancel }) => {
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);
  const [initialLoading, setInitialLoading] = useState(false);
  
  useEffect(() => {
    if (id) {
      setInitialLoading(true);
      fetchStudentById(id).then(data => {
        form.setFieldsValue(data);
      }).finally(() => {
        setInitialLoading(false);
      });
    }
  }, [id, form]);
  
  const handleSubmit = async (values) => {
    try {
      setLoading(true);
      await saveStudent(values);
      message.success('保存成功');
      onSuccess?.();
    } catch (error) {
      message.error('保存失败');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Spin spinning={initialLoading}>
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
      >
        <Form.Item
          name="name"
          label="姓名"
          rules={[{ required: true, message: '请输入姓名' }]}
        >
          <Input />
        </Form.Item>
        
        {/* 其他表单项 */}
        
        <Form.Item>
          <Space>
            <Button type="primary" htmlType="submit" loading={loading}>
              保存
            </Button>
            <Button onClick={onCancel}>取消</Button>
          </Space>
        </Form.Item>
      </Form>
    </Spin>
  );
};
```

### 模态框表单

- 将表单内嵌在Modal中
- 在确认前验证表单
- 关闭时重置表单状态

```tsx
const ModalForm = ({ visible, onCancel, onSuccess, initialValues }) => {
  const [form] = Form.useForm();
  const [submitLoading, setSubmitLoading] = useState(false);
  
  useEffect(() => {
    if (visible && initialValues) {
      form.setFieldsValue(initialValues);
    }
  }, [visible, initialValues, form]);
  
  const handleSubmit = () => {
    form.validateFields().then(async values => {
      setSubmitLoading(true);
      try {
        await saveData(values);
        message.success('操作成功');
        form.resetFields();
        onSuccess?.();
      } catch (error) {
        message.error('操作失败');
      } finally {
        setSubmitLoading(false);
      }
    });
  };
  
  const handleCancel = () => {
    form.resetFields();
    onCancel?.();
  };
  
  return (
    <Modal
      title="添加学员"
      open={visible}
      onOk={handleSubmit}
      onCancel={handleCancel}
      confirmLoading={submitLoading}
      destroyOnClose
    >
      <Form
        form={form}
        layout="vertical"
      >
        <Form.Item
          name="name"
          label="姓名"
          rules={[{ required: true, message: '请输入姓名' }]}
        >
          <Input />
        </Form.Item>
        
        {/* 其他表单项 */}
      </Form>
    </Modal>
  );
};
```

## 表单数据处理

### 数据转换

- 表单提交前转换数据格式
- 加载初始值时转换后端数据格式
- 使用工具函数处理常见转换逻辑

```tsx
// 表单提交前转换
const handleSubmit = (values) => {
  // 转换日期字段格式
  const formattedValues = {
    ...values,
    birthday: values.birthday?.format('YYYY-MM-DD'),
    // 转换多选值为数组
    interests: values.interests?.join(','),
    // 移除空值
    ...Object.fromEntries(
      Object.entries(values)
        .filter(([_, v]) => v !== undefined && v !== null && v !== '')
    ),
  };
  
  submitToApi(formattedValues);
};

// 加载初始值时转换
useEffect(() => {
  if (data) {
    const initialValues = {
      ...data,
      // 转换日期字符串为moment对象
      birthday: data.birthday ? moment(data.birthday) : undefined,
      // 转换逗号分隔的字符串为数组
      interests: data.interests?.split(','),
    };
    form.setFieldsValue(initialValues);
  }
}, [data, form]);
```

### 联动表单

- 使用Form.useWatch监听字段变化
- 根据字段值动态设置其他字段
- 实现依赖字段的验证

```tsx
const [form] = Form.useForm();
const courseType = Form.useWatch('courseType', form);

useEffect(() => {
  // 根据课程类型动态设置表单字段
  if (courseType === 'ONLINE') {
    form.setFieldsValue({ requiresDevice: true });
  } else {
    form.setFieldsValue({ requiresDevice: false });
  }
}, [courseType, form]);

// 在表单中使用
<Form form={form}>
  <Form.Item name="courseType" label="课程类型">
    <Select>
      <Option value="ONLINE">线上课程</Option>
      <Option value="OFFLINE">线下课程</Option>
    </Select>
  </Form.Item>
  
  {courseType === 'ONLINE' && (
    <Form.Item name="platform" label="授课平台">
      <Input />
    </Form.Item>
  )}
  
  {courseType === 'OFFLINE' && (
    <Form.Item name="location" label="上课地点">
      <Input />
    </Form.Item>
  )}
</Form>
```

### 条件渲染与动态表单

- 根据表单值动态显示或隐藏表单项
- 使用Form.List实现动态表单数组
- 根据用户权限控制表单项的可见性或可编辑性

```tsx
// 根据表单值条件渲染
const paymentMethod = Form.useWatch('paymentMethod', form);

<Form.Item name="paymentMethod" label="支付方式">
  <Select>
    <Option value="CASH">现金</Option>
    <Option value="CARD">刷卡</Option>
    <Option value="TRANSFER">转账</Option>
  </Select>
</Form.Item>

{paymentMethod === 'TRANSFER' && (
  <>
    <Form.Item name="bankAccount" label="银行账号">
      <Input />
    </Form.Item>
    <Form.Item name="bankName" label="开户行">
      <Input />
    </Form.Item>
  </>
)}

// 根据用户权限控制编辑权限
<Form.Item name="price" label="课程价格">
  <InputNumber disabled={!hasEditPricePermission} />
</Form.Item>
```

## 表单提交与处理

### 提交流程

- 验证表单数据
- 转换表单数据为API所需格式
- 处理提交成功和失败的反馈

```tsx
const handleSubmit = async (values) => {
  try {
    // 设置加载状态
    setSubmitting(true);
    
    // 转换数据
    const formattedData = formatFormData(values);
    
    // 提交数据
    await api.saveStudent(formattedData);
    
    // 成功反馈
    message.success('保存成功');
    
    // 执行成功回调
    onSuccess?.();
  } catch (error) {
    // 错误处理
    message.error('保存失败: ' + error.message);
    console.error('表单提交错误:', error);
  } finally {
    // 清除加载状态
    setSubmitting(false);
  }
};

<Form
  form={form}
  onFinish={handleSubmit}
>
  {/* 表单内容 */}
  <Form.Item>
    <Button type="primary" htmlType="submit" loading={submitting}>
      提交
    </Button>
  </Form.Item>
</Form>
```

### 错误处理

- 处理表单验证错误
- 处理API调用错误
- 展示友好的错误信息

```tsx
// 表单验证错误处理
const handleSubmit = () => {
  form.validateFields()
    .then(values => {
      // 提交表单数据
      submitData(values);
    })
    .catch(errorInfo => {
      console.log('表单验证失败:', errorInfo);
      // 可选：滚动到第一个错误的表单项
      if (errorInfo.errorFields?.length > 0) {
        const fieldName = errorInfo.errorFields[0].name[0];
        const element = document.getElementById(`form_item_${fieldName}`);
        element?.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    });
};

// API错误处理
const submitData = async (values) => {
  try {
    await api.saveData(values);
    message.success('保存成功');
  } catch (error) {
    // 处理特定错误类型
    if (error.code === 'DUPLICATE_ENTRY') {
      message.error('数据已存在，请检查输入');
    } else if (error.code === 'PERMISSION_DENIED') {
      message.error('没有权限执行此操作');
    } else {
      message.error('操作失败: ' + (error.message || '未知错误'));
    }
    
    // 根据错误类型设置表单错误
    if (error.fieldErrors) {
      // 后端返回的字段错误
      const formErrors = {};
      error.fieldErrors.forEach(fieldError => {
        formErrors[fieldError.field] = fieldError.message;
      });
      form.setFields(
        Object.entries(formErrors).map(([name, errors]) => ({
          name: name.split('.'),
          errors: Array.isArray(errors) ? errors : [errors],
        }))
      );
    }
  }
};
```

## 表单性能优化

### 重渲染优化

- 使用memo包装表单组件
- 拆分大型表单为小型组件
- 使用Form.Item组件的noStyle属性减少DOM节点

```tsx
// 使用memo包装表单组件
const StudentForm = memo(({ initialValues, onSubmit }) => {
  // 表单实现
});

// 拆分大型表单
const StudentForm = () => {
  const [form] = Form.useForm();
  
  return (
    <Form form={form}>
      <BasicInfoSection />
      <ContactInfoSection />
      <CourseSelectionSection />
      <Form.Item>
        <Button type="primary" htmlType="submit">提交</Button>
      </Form.Item>
    </Form>
  );
};

// 使用noStyle减少DOM节点
<Form.Item label="价格区间">
  <Space>
    <Form.Item name="minPrice" noStyle>
      <InputNumber placeholder="最低价" />
    </Form.Item>
    <span>至</span>
    <Form.Item name="maxPrice" noStyle>
      <InputNumber placeholder="最高价" />
    </Form.Item>
  </Space>
</Form.Item>
```

### 延迟加载

- 使用懒加载加载不常用的表单部分
- 分步表单减少初始渲染内容
- 根据需要动态加载表单选项数据

```tsx
// 使用懒加载加载不常用的表单部分
const AdvancedSettings = lazy(() => import('./AdvancedSettings'));

<Form>
  <BasicSettings />
  <Collapse>
    <Panel header="高级设置" key="advanced">
      <Suspense fallback={<Skeleton active />}>
        <AdvancedSettings />
      </Suspense>
    </Panel>
  </Collapse>
</Form>

// 分步表单
const steps = ['基本信息', '课程选择', '付款信息'];
const [currentStep, setCurrentStep] = useState(0);

const next = () => {
  form.validateFields().then(() => {
    setCurrentStep(currentStep + 1);
  });
};

const prev = () => {
  setCurrentStep(currentStep - 1);
};

// 渲染当前步骤的表单内容
const renderStepContent = () => {
  switch (currentStep) {
    case 0:
      return <BasicInfoForm form={form} />;
    case 1:
      return <CourseSelectionForm form={form} />;
    case 2:
      return <PaymentInfoForm form={form} />;
    default:
      return null;
  }
};

return (
  <Form form={form}>
    <Steps current={currentStep}>
      {steps.map(item => (
        <Step key={item} title={item} />
      ))}
    </Steps>
    
    <div style={{ marginTop: 24 }}>
      {renderStepContent()}
    </div>
    
    <div style={{ marginTop: 24 }}>
      {currentStep > 0 && (
        <Button style={{ margin: '0 8px' }} onClick={prev}>
          上一步
        </Button>
      )}
      {currentStep < steps.length - 1 && (
        <Button type="primary" onClick={next}>
          下一步
        </Button>
      )}
      {currentStep === steps.length - 1 && (
        <Button type="primary" onClick={handleSubmit}>
          提交
        </Button>
      )}
    </div>
  </Form>
);
```

## 最佳实践总结

### 常见陷阱与解决方案

- 初始值格式不一致：确保前后端数据格式一致，必要时进行转换
- 表单重置不完整：使用form.resetFields()确保完全重置
- 条件渲染导致字段丢失：使用Form.Item的preserve属性保留字段值

```tsx
// 解决初始值格式不一致
const transformInitialValues = (data) => {
  if (!data) return {};
  
  return {
    ...data,
    birthday: data.birthday ? moment(data.birthday) : undefined,
    tags: data.tags ? data.tags.split(',') : [],
  };
};

// 条件渲染保留字段值
<Form.Item 
  name="onlineUrl" 
  label="线上课程链接"
  preserve={true} // 即使不渲染，也保留字段值
  hidden={courseType !== 'ONLINE'}
>
  <Input />
</Form.Item>
```

### 可维护性提示

- 集中管理表单配置
- 抽取常用验证规则
- 使用TypeScript定义表单数据类型

```tsx
// 集中管理表单配置
const formConfig = {
  studentForm: {
    layout: 'vertical',
    fields: {
      name: {
        label: '姓名',
        rules: [{ required: true, message: '请输入姓名' }],
        component: <Input />,
      },
      age: {
        label: '年龄',
        rules: [{ required: true, message: '请输入年龄' }],
        component: <InputNumber min={1} max={100} />,
      },
      // 其他字段...
    },
  },
};

// 使用配置生成表单
const renderFormItems = () => {
  return Object.entries(formConfig.studentForm.fields).map(([name, config]) => (
    <Form.Item
      key={name}
      name={name}
      label={config.label}
      rules={config.rules}
    >
      {config.component}
    </Form.Item>
  ));
};

// 使用TypeScript定义表单数据类型
interface StudentFormValues {
  name: string;
  age?: number;
  gender: 'male' | 'female';
  courses: {
    id: string;
    name: string;
    hours: number;
  }[];
}

const handleSubmit = (values: StudentFormValues) => {
  // 类型安全的表单处理
};
```
